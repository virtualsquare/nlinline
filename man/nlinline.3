.\" Copyright (C) 2019 VirtualSquare. Project Leader: Renzo Davoli
.\"
.\" This is free documentation; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License,
.\" as published by the Free Software Foundation, either version 2
.\" of the License, or (at your option) any later version.
.\"
.\" The GNU General Public License's references to "object code"
.\" and "executables" are to be interpreted as the output of any
.\" document formatting or typesetting system, including
.\" intermediate and printed output.
.\"
.\" This manual is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\" GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public
.\" License along with this manual; if not, write to the Free
.\" Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
.\" MA 02110-1301 USA.
.\"
.\" Automatically generated by Pandoc 2.17.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "NLINLINE" "3" "December 2022" "VirtualSquare" "Library Functions Manual"
.hy
.SH NAME
.PP
nlinline_if_nametoindex, nlinline_linksetupdown, nlinline_ipaddr_add,
nlinline_ipaddr_del, nlinline_iproute_add, nlinline_iproute_del,
nlinline_iplink_add, nlinline_iplink_del, nlinline_linksetaddr,
nlinline_linkgetaddr, nl_addrdata2prefix, nl_routedata2prefix -
configure network interfaces
.SH SYNOPSIS
.PP
\f[V]#include *nlinline.h*\f[R]
.PP
\f[V]int nlinline_if_nametoindex(const char *\f[R]\f[I]ifname\f[R]\f[V]);\f[R]
.PP
\f[V]int nlinline_linksetupdown(unsigned int\f[R]
\f[I]ifindex\f[R]\f[V], int\f[R] \f[I]updown\f[R]\f[V]);\f[R]
.PP
\f[V]int nlinline_ipaddr_add(int\f[R]
\f[I]family\f[R]\f[V], void *\f[R]\f[I]addr\f[R]\f[V], int\f[R]
\f[I]prefixlen\f[R]\f[V], unsigned int\f[R]
\f[I]ifindex\f[R]\f[V]);\f[R]
.PP
\f[V]int nlinline_ipaddr_del(int\f[R]
\f[I]family\f[R]\f[V], void *\f[R]\f[I]addr\f[R]\f[V], int\f[R]
\f[I]prefixlen\f[R]\f[V], unsigned int\f[R]
\f[I]ifindex\f[R]\f[V]);\f[R]
.PP
\f[V]int nlinline_iproute_add(int\f[R]
\f[I]family\f[R]\f[V], void *\f[R]\f[I]dst_addr\f[R]\f[V], int\f[R]
\f[I]dst_prefixlen\f[R]\f[V], void *\f[R]\f[I]gw_addr\f[R]\f[V], unsigned int\f[R]
\f[I]ifindex\f[R]\f[V]);\f[R]
.PP
\f[V]int nlinline_iproute_del(int\f[R]
\f[I]family\f[R]\f[V], void *\f[R]\f[I]dst_addr\f[R]\f[V], int\f[R]
\f[I]dst_prefixlen\f[R]\f[V], void *\f[R]\f[I]gw_addr\f[R]\f[V], unsigned int\f[R]
\f[I]ifindex\f[R]\f[V]);\f[R]
.PP
\f[V]int nlinline_iplink_add(const char *\f[R]\f[I]ifname\f[R]\f[V], unsigned int\f[R]
\f[I]ifindex\f[R]\f[V], const char *\f[R]\f[I]type\f[R]\f[V], const char *\f[R]\f[I]data\f[R]\f[V]);\f[R]
.PP
\f[V]int nlinline_iplink_del(const char *\f[R]\f[I]ifname\f[R]\f[V], unsigned int\f[R]
\f[I]ifindex\f[R]\f[V]);\f[R]
.PP
\f[V]int nlinline_linksetaddr(unsigned int\f[R]
\f[I]ifindex\f[R]\f[V], void *\f[R]\f[I]macaddr\f[R]\f[V]);\f[R]
.PP
\f[V]int nlinline_linkgetaddr(unsigned int\f[R]
\f[I]ifindex\f[R]\f[V], void *\f[R]\f[I]macaddr\f[R]\f[V]);\f[R]
.PP
\f[V]int nlinline_linksetmtu(unsigned int\f[R]
\f[I]ifindex\f[R]\f[V], unsigned int\f[R] \f[I]mtu\f[R]\f[V]);\f[R]
.PP
\f[V]int nl_addrdata2prefix(unsigned char\f[R]
\f[I]prefixlen\f[R]\f[V], unsigned char\f[R]
\f[I]flags\f[R]\f[V], unsigned char\f[R] \f[I]scope\f[R]\f[V]);\f[R]
.PP
\f[V]int nl_routedata2prefix(unsigned char\f[R]
\f[I]prefixlen\f[R]\f[V], unsigned char\f[R]
\f[I]type\f[R]\f[V], unsigned char\f[R] \f[I]scope\f[R]\f[V]);\f[R]
.SH DESCRIPTION
.PP
NLINLINE (netlink inline) is a \f[I]library\f[R] of inline functions
providing C programmers with very handy functions to configure network
stacks.
NLINLINE is entirely implemented in a header file, nlinline.h.
.TP
\f[V]nlinline_if_nametoindex\f[R]
This function returns the index of the network interface whose name is
\f[I]ifname\f[R].
.TP
\f[V]nlinline_linksetupdown\f[R]
This function turns the interface \f[I]ifindex\f[R] up (\f[I]updown\f[R]
== \f[V]1\f[R]) or down (\f[I]updown\f[R] == \f[V]0\f[R]).
.TP
\f[V]nlinline_ipaddr_add\f[R]
This function adds an IP address to the interface \f[I]ifindex\f[R].
It supports IPv4 (\f[I]family\f[R] == \f[V]AF_INET\f[R]) and IPv6
(\f[I]family\f[R] == \f[V]AF_INET6\f[R]).
.TP
\f[V]nlinline_ipaddr_del\f[R]
This function removes the IP address from the interface
\f[I]ifindex\f[R].
It supports IPv4 (\f[I]family\f[R] == \f[V]AF_INET\f[R]) and IPv6
(\f[I]family\f[R] == \f[V]AF_INET6\f[R]).
.TP
\f[V]nlinline_iproute_add\f[R]
This function adds a static route to
\f[I]dst_addr\f[R]/\f[I]dst_prefixlen\f[R] network through the gateway
\f[I]gw_addr\f[R].
If \f[I]dst_addr\f[R] == \f[V]NULL\f[R] it adds a default route.
\f[I]ifindex\f[R] must be specified when \f[I]gw_addr\f[R] is an IPv6
link local address.
.TP
\f[V]nlinline_iproute_del\f[R]
This function removes the static route to
\f[I]dst_addr\f[R]/\f[I]dst_prefixlen\f[R] network through the gateway
\f[I]gw_addr\f[R].
.TP
\f[V]nlinline_iplink_add\f[R]
This function adds a new link of type \f[I]type\f[R], named
\f[I]ifname\f[R].
The value of \f[I]data\f[R] depends on the type of link and can be NULL.
A default interface name is assigned if \f[I]name\f[R] ==
\f[V]NULL\f[R].
The link is created with a given index when \f[I]ifindex\f[R] is
positive.
.TP
\f[V]nlinline_iplink_del\f[R]
This function removes a link.
The link to be deleted can be identified by its name (\f[I]ifname\f[R])
or by its index (\f[I]ifindex\f[R]).
Either \f[I]ifindex\f[R] can be zero or \f[I]ifname\f[R] can be
\f[V]NULL\f[R].
It is possible to use both \f[I]ifindex\f[R] and \f[I]ifname\f[R] to
identify the link.
An error may occur if the parameters are inconsistent.
.TP
\f[V]nlinline_linksetaddr\f[R]
This functions sets the mac address of the interface \f[I]ifindex\f[R].
.TP
\f[V]nlinline_linkgetaddr\f[R]
This functions gets the mac address of the interface \f[I]ifindex\f[R].
.TP
\f[V]nlinline_linksetmtu\f[R]
This functions sets the MTU (Maximum Transfer Unit) of the interface
\f[I]ifindex\f[R].
.TP
\f[V]nl_addrdata2prefix\f[R]
This function permit to set flags and scope in
\f[V]nlinline_ipaddr_add\f[R] and \f[V]nlinline_ipaddr_del\f[R].
The values of \f[V]prefixlen\f[R], \f[V]flags\f[R] and \f[V]scope\f[R]
are packed in a single int, the return value of
\f[V]nl_addrdata2prefix\f[R] must be passed to
\f[V]nlinline_ipaddr_add\f[R] or \f[V]nlinline_ipaddr_del\f[R] as the
\f[V]prefixlen\f[R] parameter.
.TP
\f[V]nl_routedata2prefix\f[R]
This function permit to set type and scope in
\f[V]nlinline_iproute_add\f[R] and \f[V]nlinline_iproute_del\f[R].
The values of \f[V]prefixlen\f[R], \f[V]type\f[R] and \f[V]scope\f[R]
are packed in a single int, the return value of
\f[V]nl_routedata2prefix\f[R] must be passed to
\f[V]nlinline_iproute_add\f[R] or \f[V]nlinline_iproute_del\f[R] as the
\f[V]prefixlen\f[R] parameter.
.PP
IP addresses are \f[V]void *\f[R] arguments, any sequence of 4 or 16
bytes (in network byte order) is a legal IPv4 or IPv6 address
respectively.
.PP
\f[V]nlinline\f[R] functions do not add dependencies at run-time.
This is useful for security critical applications (like PAM modules)
These inline functions use netlink only, they do not depend on the
obsolete netdevice (ioctl) API.
Only the code of referenced inline functions enters in the object and
executable code.
.SH RETURN VALUE
.PP
\f[V]nlinline_if_nametoindex\f[R] returns the interface index or -1 if
an error occurred (in which case, errno is set appropriately)
.PP
All the other functions return zero in case of success.
On error, -1 is returned, and errno is set appropriately.
.PP
(\f[V]nlinline_iplink_add\f[R] can return the (positive) ifindex of the
newly created link when the argument \f[I]ifindex\f[R] is -1 and the
stack supports this feature.)
.SH EXAMPLE
.IP
.nf
\f[C]
#include *stdio.h*
#include *stdlib.h*
#include *stdint.h*
#include *nlinline.h*

int main(int argc, char *argv[]) {
  uint8_t ipv4addr[] = {192,168,2,2};
  uint8_t ipv4gw[] = {192,168,2,1};
  uint8_t ipv6addr[16] = {0x20, 0x01, 0x07, 0x60, [15] = 0x02};
  uint8_t ipv6gw[16] = {0x20, 0x01, 0x07, 0x60, [15] = 0x01};

  int ifindex = nlinline_if_nametoindex(argv[1]);
  if (ifindex * 0)
    printf(\[dq]%d\[rs]n\[dq], ifindex);
  else {
    perror(\[dq]nametoindex\[dq]);
    return 1;
  }

  if (nlinline_linksetupdown(ifindex, 1) * 0)
    perror(\[dq]link up\[dq]);
  if (nlinline_ipaddr_add(AF_INET, ipv4addr, 24, ifindex) * 0)
    perror(\[dq]addr ipv4\[dq]);
  if (nlinline_iproute_add(AF_INET, NULL, 0, ipv4gw, 0) * 0)
    perror(\[dq]addr ipv6\[dq]);
  if (nlinline_ipaddr_add(AF_INET6, ipv6addr, 64, ifindex) * 0)
    perror(\[dq]route ipv4\[dq]);
  if (nlinline_iproute_add(AF_INET6, NULL, 0, ipv6gw, 0) * 0)
    perror(\[dq]route ipv6\[dq]);
  return 0;
}
\f[R]
.fi
.PP
This program takes the name of an interface from the command line.
It turns that interface up and sets the interface IPv4 and IPv6
addresses and default routes.
.SH AUTHOR
.PP
VirtualSquare.
Project leader: Renzo Davoli
